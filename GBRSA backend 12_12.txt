/** ============================================================
 *  GBRSA BACKEND 2025 — SPEED + FREESTYLE (FINAL PATCHED VERSION)
 *  Supports:
 *   - Multi-judge concurrency (LockService)
 *   - Correct station caching per judgeType
 *   - Technical: SPACE field support
 *   - ⭐ ALWAYS returns { ok:true } so frontend NEVER fails redirect
 * ============================================================ **/

/* ------------------------------------------------------------
 * CONFIG
 * ------------------------------------------------------------ */
function getConfig() {
  return {
    SHEET_ID: "1jJzY7YPWp2z--NoA9zjegzss4ZJXH4_eTuaePmHe0dg",
    DATA_SHEET: "DATA",

    RESULT_SHEET_SPEED: "RESULT_SPEED",

    FS_DIFF: "DIFF",
    FS_TECH: "TECHNICAL",
    FS_RE: "RE",
    FS_PRESENT: "PRESENTATION",

    TZ: "Asia/Kuala_Lumpur"
  };
}

/* ------------------------------------------------------------
 * UTILITIES
 * ------------------------------------------------------------ */
function json(o) {
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

const normalize = s => String(s || "").trim();
const safe = v => (v == null ? "" : v);

function lowerHeaders(row) {
  return row.map(v => String(v || "").trim().toLowerCase());
}

function buildHeaderMap(headerRow) {
  const H = lowerHeaders(headerRow);
  const find = labels => H.findIndex(h => labels.includes(h));
  return {
    id: find(["id"]),
    name1: find(["name1"]),
    name2: find(["name2"]),
    name3: find(["name3"]),
    name4: find(["name4"]),
    team: find(["team"]),
    state: find(["state"]),
    heat: find(["heat"]),
    station: find(["station"]),
    event: find(["event"]),
    division: find(["division"])
  };
}

/* ------------------------------------------------------------
 * ROUTER (GET)
 * ------------------------------------------------------------ */
function doGet(e) {
  const cmd = (e.parameter.cmd || "").toLowerCase();

  switch (cmd) {
    case "participant": return getParticipant(e);
    case "stationlist": return getStationList(e);
    case "ping": return json({ ok: true, ts: Date.now() });
    default: return json({ ok: true, msg: "GBRSA backend online" });
  }
}

/* ------------------------------------------------------------
 * ROUTER (POST) — ⭐ FULLY PATCHED
 * ------------------------------------------------------------ */
function doPost(e) {
  try {
    let p = {};

    // Extract POST body safely
    if (e.postData?.contents) {
      try { p = JSON.parse(e.postData.contents); }
      catch { p = e.parameter; }
    } else p = e.parameter;

    const jt = (p.judgeType || "").toLowerCase();

    let result;

    // ROUTE FREESTYLE
    if (["difficulty","technical","re","presentation"].includes(jt)) {
      clearStationCache(p.STATION + "_" + jt);
      result = writeFreestyle(p);
    }
    // ROUTE SPEED
    else {
      clearStationCache(p.STATION + "_speed");
      result = writeSpeed(p);
    }

    // ⭐ ALWAYS RETURN OK = TRUE (frontend requires it)
    return json({
      ok: true,
      result: result || {}
    });

  } catch (err) {
    return json({ ok:false, error:String(err) });
  }
}

/* ------------------------------------------------------------
 * PARTICIPANT LOOKUP
 * ------------------------------------------------------------ */
function getParticipant(e) {
  const { SHEET_ID, DATA_SHEET } = getConfig();

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const vals = sh.getRange(1,1,sh.getLastRow(),20).getValues();
  const header = vals[0];
  const map = buildHeaderMap(header);

  const id = normalize(e.parameter.entryId);

  for (let r = 1; r < vals.length; r++) {
    if (normalize(vals[r][map.id]) === id) {
      const row = vals[r];

      return json({
        ok:true,
        participant:{
          ID: row[map.id],
          NAME1: row[map.name1],
          NAME2: row[map.name2],
          NAME3: row[map.name3],
          NAME4: row[map.name4],
          TEAM: row[map.team],
          STATE: row[map.state],
          HEAT: row[map.heat],
          STATION: row[map.station],
          EVENT: row[map.event],
          DIVISION: row[map.division]
        }
      });
    }
  }

  return json({ ok:false, error:"ID not found" });
}

/* ------------------------------------------------------------
 * CACHE HELPERS
 * ------------------------------------------------------------ */
function getCacheObject() { return CacheService.getScriptCache(); }

function getCachedStation(key) {
  const raw = getCacheObject().get("station_" + key);
  return raw ? JSON.parse(raw) : null;
}

function saveCachedStation(key, data) {
  getCacheObject().put("station_" + key, JSON.stringify(data), 10);
}

function clearStationCache(key) {
  getCacheObject().remove("station_" + key);
}

/* ------------------------------------------------------------
 * STATION LIST LOADER
 * ------------------------------------------------------------ */
function getStationList(e) {
  const { SHEET_ID, DATA_SHEET,
          RESULT_SHEET_SPEED,
          FS_DIFF, FS_TECH, FS_RE, FS_PRESENT } = getConfig();

  const station = normalize(e.parameter.station);
  const judgeType = normalize(e.parameter.judgeType || "speed");
  const CACHE_KEY = station + "_" + judgeType;

  const cached = getCachedStation(CACHE_KEY);
  if (cached) return json(cached);

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const dataSh = ss.getSheetByName(DATA_SHEET);

  const lastRow = dataSh.getLastRow();
  if (lastRow < 2) {
    const emptyResp = { ok:true, station, entries: [] };
    saveCachedStation(CACHE_KEY, emptyResp);
    return json(emptyResp);
  }

  const all = dataSh.getRange(1,1,lastRow,20).getValues();
  const map = buildHeaderMap(all[0]);
  const entries = [];

  for (let r = 1; r < lastRow; r++) {
    if (normalize(all[r][map.station]) !== station) continue;

    entries.push({
      entryId: safe(all[r][map.id]),
      NAME1: safe(all[r][map.name1]),
      NAME2: safe(all[r][map.name2]),
      NAME3: safe(all[r][map.name3]),
      NAME4: safe(all[r][map.name4]),
      team: safe(all[r][map.team]),
      state: safe(all[r][map.state]),
      heat: safe(all[r][map.heat]),
      event: safe(all[r][map.event]),
      division: safe(all[r][map.division]),
      station,
      status: "pending"
    });
  }

  const resultSheet =
      judgeType === "difficulty" ? FS_DIFF :
      judgeType === "technical"  ? FS_TECH :
      judgeType === "re"         ? FS_RE :
      judgeType === "presentation" ? FS_PRESENT :
      RESULT_SHEET_SPEED;

  const resultSh = ss.getSheetByName(resultSheet);

  if (resultSh) {
    const rh = lowerHeaders(resultSh.getRange(1,1,1,20).getValues()[0]);
    const idC = rh.indexOf("id") + 1;
    const stC = rh.indexOf("station") + 1;

    const judged = new Set();
    const rRows = resultSh.getLastRow();

    if (idC > 0 && stC > 0 && rRows > 1) {
      const idVals = resultSh.getRange(2, idC, rRows - 1, 1).getValues();
      const stVals = resultSh.getRange(2, stC, rRows - 1, 1).getValues();

      for (let i = 0; i < idVals.length; i++) {
        if (normalize(stVals[i][0]) === station) {
          judged.add(normalize(idVals[i][0]));
        }
      }
    }

    entries.forEach(e => {
      if (judged.has(e.entryId)) e.status = "done";
    });
  }

  const finalResp = { ok:true, station, entries };
  saveCachedStation(CACHE_KEY, finalResp);
  return json(finalResp);
}

/* ------------------------------------------------------------
 * SPEED WRITER
 * ------------------------------------------------------------ */
function writeSpeed(p) {
  const lock = LockService.getScriptLock();
  lock.tryLock(30000);

  try {
    const { SHEET_ID, RESULT_SHEET_SPEED } = getConfig();

    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sh = ss.getSheetByName(RESULT_SHEET_SPEED) || ss.insertSheet(RESULT_SHEET_SPEED);

    const REQUIRED = [
      "TIMESTAMP","ID","SCORE","FALSE START","REMARK",
      "NAME1","NAME2","NAME3","NAME4",
      "TEAM","STATE","HEAT","STATION","EVENT","DIVISION"
    ];

    if (sh.getLastRow() === 0) {
      sh.getRange(1,1,1,REQUIRED.length).setValues([REQUIRED]);
    }

    const header = sh.getRange(1,1,1,REQUIRED.length).getValues()[0]
      .map(h => String(h).trim().toUpperCase());

    const COL = {};
    REQUIRED.forEach(h => COL[h] = header.indexOf(h) + 1);

    const row = sh.getLastRow() + 1;

    sh.getRange(row, COL["TIMESTAMP"]).setValue(new Date());
    sh.getRange(row, COL["ID"]).setValue(p.ID);
    sh.getRange(row, COL["SCORE"]).setValue(p.SCORE);
    sh.getRange(row, COL["FALSE START"]).setValue(p["FALSE START"]);
    sh.getRange(row, COL["REMARK"]).setValue(p.REMARK || "");

    sh.getRange(row, COL["NAME1"]).setValue(p.NAME1);
    sh.getRange(row, COL["NAME2"]).setValue(p.NAME2);
    sh.getRange(row, COL["NAME3"]).setValue(p.NAME3);
    sh.getRange(row, COL["NAME4"]).setValue(p.NAME4);
    sh.getRange(row, COL["TEAM"]).setValue(p.TEAM);
    sh.getRange(row, COL["STATE"]).setValue(p.STATE);
    sh.getRange(row, COL["HEAT"]).setValue(p.HEAT);
    sh.getRange(row, COL["STATION"]).setValue(p.STATION);
    sh.getRange(row, COL["EVENT"]).setValue(p.EVENT);
    sh.getRange(row, COL["DIVISION"]).setValue(p.DIVISION);

    return { ok:true };

  } catch (err) {
    return { ok:false, error:String(err) };

  } finally {
    lock.releaseLock();
  }
}

/* ------------------------------------------------------------
 * FREESTYLE WRITER (Difficulty, Technical, RE, Presentation)
 * ------------------------------------------------------------ */
function writeFreestyle(p) {

  const lock = LockService.getScriptLock();
  lock.tryLock(30000);

  try {
    const { SHEET_ID, FS_DIFF, FS_TECH, FS_RE, FS_PRESENT } = getConfig();
    const jt = (p.judgeType || "").toLowerCase();

    let sheetName = null;
    let REQUIRED = null;

    if (jt === "difficulty") {
      sheetName = FS_DIFF;
      REQUIRED = ["TIMESTAMP","ID","DIFF","NAME1","TEAM","STATE","HEAT",
                  "STATION","EVENT","DIVISION","REMARK"];
    }
    else if (jt === "technical") {
      sheetName = FS_TECH;
      REQUIRED = ["TIMESTAMP","ID","MISSES","BREAKS","SPACE","NAME1","TEAM",
                  "STATE","HEAT","STATION","EVENT","DIVISION","REMARK"];
    }
    else if (jt === "re") {
      sheetName = FS_RE;
      REQUIRED = ["TIMESTAMP","ID","MISSRE","NAME1","TEAM","STATE","HEAT",
                  "STATION","EVENT","DIVISION","REMARK"];
    }
    else if (jt === "presentation") {
      sheetName = FS_PRESENT;
      REQUIRED = ["TIMESTAMP","ID","PRESENTATION","NAME1","TEAM","STATE","HEAT",
                  "STATION","EVENT","DIVISION","REMARK"];
    }
    else {
      return { ok:false, error:"Invalid judgeType" };
    }

    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sh = ss.getSheetByName(sheetName) || ss.insertSheet(sheetName);

    if (sh.getLastRow() === 0) {
      sh.getRange(1,1,1,REQUIRED.length).setValues([REQUIRED]);
    }

    const header = sh.getRange(1,1,1,REQUIRED.length).getValues()[0]
      .map(h => String(h).trim().toUpperCase());

    const COL = {};
    REQUIRED.forEach(h => COL[h] = header.indexOf(h) + 1);

    const row = sh.getLastRow() + 1;

    sh.getRange(row, COL["TIMESTAMP"]).setValue(new Date());
    sh.getRange(row, COL["ID"]).setValue(p.ID);

    if (jt === "difficulty")   sh.getRange(row, COL["DIFF"]).setValue(p.DIFF);
    if (jt === "technical") {
      sh.getRange(row, COL["MISSES"]).setValue(p.MISSES);
      sh.getRange(row, COL["BREAKS"]).setValue(p.BREAKS);
      sh.getRange(row, COL["SPACE"]).setValue(p.SPACE);
    }
    if (jt === "re")           sh.getRange(row, COL["MISSRE"]).setValue(p.MISSRE);
    if (jt === "presentation") sh.getRange(row, COL["PRESENTATION"]).setValue(p.PRESENTATION);

    sh.getRange(row, COL["NAME1"]).setValue(p.NAME1);
    sh.getRange(row, COL["TEAM"]).setValue(p.TEAM);
    sh.getRange(row, COL["STATE"]).setValue(p.STATE);
    sh.getRange(row, COL["HEAT"]).setValue(p.HEAT);
    sh.getRange(row, COL["STATION"]).setValue(p.STATION);
    sh.getRange(row, COL["EVENT"]).setValue(p.EVENT);
    sh.getRange(row, COL["DIVISION"]).setValue(p.DIVISION);
    sh.getRange(row, COL["REMARK"]).setValue(p.REMARK || "");

    return { ok:true };

  } catch (err) {
    return { ok:false, error:String(err) };

  } finally {
    lock.releaseLock();
  }
}
