/** ============================================================
 *  GBRSA BACKEND 2025 — CLEAN SPEED-ONLY VERSION
 *  Supports:
 *   ✔ SPEED scoring (append)
 *   ✔ SPEED station list
 *   ✔ PARTICIPANT lookup
 *   ✔ AUTO header detection
 * ============================================================ **/

/* ------------------------------------------------------------
 * 1️⃣ FIXED CONFIG
 * ------------------------------------------------------------ */
function getConfig() {
  return {
    SHEET_ID: "1jJzY7YPWp2z--NoA9zjegzss4ZJXH4_eTuaePmHe0dg",   // your sheet ID
    DATA_SHEET: "DATA",
    RESULT_SHEET_SPEED: "RESULT_SPEED",
    TZ: "Asia/Kuala_Lumpur"
  };
}

/* ------------------------------------------------------------
 *  UTILITIES
 * ------------------------------------------------------------ */
function json(o) {
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

const normalize = s => String(s || "").trim();
const safe = v => (v == null ? "" : v);

function lowerHeaders(row) {
  return row.map(v => String(v || "").trim().toLowerCase());
}

/* ------------------------------------------------------------
 *  HEADER MAPPING
 * ------------------------------------------------------------ */
function buildHeaderMap(headerRow) {
  const H = lowerHeaders(headerRow);
  const find = nameList => H.findIndex(h => nameList.includes(h));
  return {
    id: find(["id"]),
    name1: find(["name1"]),
    name2: find(["name2"]),
    name3: find(["name3"]),
    name4: find(["name4"]),
    team: find(["team"]),
    state: find(["state"]),
    heat: find(["heat"]),
    station: find(["station"]),
    event: find(["event"]),
    division: find(["division"])
  };
}

/* ------------------------------------------------------------
 *  ROUTER
 * ------------------------------------------------------------ */
function doGet(e) {
  const cmd = (e.parameter.cmd || "").toLowerCase();

  switch (cmd) {
    case "participant":
      return getParticipant(e);
    case "stationlist":
      return getStationList(e);
    case "ping":
      return json({ ok: true, ts: Date.now() });
    default:
      return json({ ok: true, msg: "GBRSA backend online" });
  }
}

function doPost(e) {
  try {
    let p = {};
    if (e.postData?.contents) {
      try { p = JSON.parse(e.postData.contents); }
      catch { p = e.parameter; }
    } else p = e.parameter;

    return json(writeSpeed(p));
  } catch (err) {
    return json({ ok: false, error: String(err) });
  }
}

/* ------------------------------------------------------------
 *  PARTICIPANT LOOKUP
 * ------------------------------------------------------------ */
function getParticipant(e) {
  const { SHEET_ID, DATA_SHEET } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const vals = sh.getRange(1, 1, sh.getLastRow(), 20).getValues();
  const header = vals[0];
  const map = buildHeaderMap(header);

  const id = normalize(e.parameter.entryId);

  for (let r = 1; r < vals.length; r++) {
    if (normalize(vals[r][map.id]) === id) {
      const row = vals[r];
      return json({
        ok: true,
        participant: {
          ID: id,
          NAME1: row[map.name1],
          NAME2: row[map.name2],
          NAME3: row[map.name3],
          NAME4: row[map.name4],
          TEAM: row[map.team],
          STATE: row[map.state],
          HEAT: row[map.heat],
          STATION: row[map.station],
          EVENT: row[map.event],
          DIVISION: row[map.division]
        }
      });
    }
  }

  return json({ ok: false, error: "ID not found" });
}

/* ------------------------------------------------------------
 *  SPEED STATION LIST
 * ------------------------------------------------------------ */
function getStationList(e) {
  const { SHEET_ID, DATA_SHEET, RESULT_SHEET_SPEED } = getConfig();
  const station = normalize(e.parameter.station);

  const ss = SpreadsheetApp.openById(SHEET_ID);

  // --- READ DATA SHEET ---
  const dataSh = ss.getSheetByName(DATA_SHEET);
  const dVals = dataSh.getRange(1, 1, dataSh.getLastRow(), 20).getValues();
  const header = dVals[0];
  const map = buildHeaderMap(header);

  const entries = [];

  for (let r = 1; r < dVals.length; r++) {
    if (normalize(dVals[r][map.station]) !== station) continue;

    const id = normalize(dVals[r][map.id]);
    if (!id) continue;

    const row = dVals[r];

    entries.push({
      entryId: id,
      NAME1: safe(row[map.name1]),
      NAME2: safe(row[map.name2]),
      NAME3: safe(row[map.name3]),
      NAME4: safe(row[map.name4]),
      team: safe(row[map.team]),
      state: safe(row[map.state]),
      heat: safe(row[map.heat]),
      station,
      event: safe(row[map.event]),
      division: safe(row[map.division]),
      displayName: [row[map.name1], row[map.name2], row[map.name3], row[map.name4]]
        .filter(Boolean).join(" "),
      status: "pending"
    });
  }

  // --- READ SPEED RESULT SHEET ---
  const resultSh = ss.getSheetByName(RESULT_SHEET_SPEED);
  const judgedToday = new Set();

  if (resultSh) {
    const rv = resultSh.getRange(1, 1, resultSh.getLastRow(), 20).getValues();
    const rh = lowerHeaders(rv[0]);

    const tsC = rh.indexOf("timestamp");
    const idC = rh.indexOf("id");
    const stC = rh.indexOf("station");

    if (tsC !== -1 && idC !== -1 && stC !== -1) {
      const now = new Date();

      for (let r = 1; r < rv.length; r++) {
        const ts = rv[r][tsC];
        if (!(ts instanceof Date)) continue;

        const same =
          ts.getFullYear() === now.getFullYear() &&
          ts.getMonth() === now.getMonth() &&
          ts.getDate() === now.getDate();

        if (same && normalize(rv[r][stC]) === station) {
          judgedToday.add(normalize(rv[r][idC]));
        }
      }
    }
  }

  entries.forEach(e => {
    if (judgedToday.has(e.entryId)) e.status = "done";
  });

  return json({ ok: true, station, entries });
}

/* ------------------------------------------------------------
 *  SPEED WRITER — FULL AUTO HEADER DETECTION
 * ------------------------------------------------------------ */
function writeSpeed(p) {
  const { SHEET_ID, RESULT_SHEET_SPEED } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(RESULT_SHEET_SPEED) || ss.insertSheet(RESULT_SHEET_SPEED);

  const header = [
    "TIMESTAMP","ID","SCORE","FALSE START","REMARK",
    "NAME1","NAME2","NAME3","NAME4",
    "TEAM","STATE","HEAT","STATION","EVENT","DIVISION"
  ];

  const lastRow = sh.getLastRow();

  // If completely empty, write header
  if (lastRow === 0) {
    sh.getRange(1,1,1,header.length).setValues([header]);
  }

  // Detect header row in case user shifts rows
  const range = sh.getRange(1,1,Math.max(1,lastRow), header.length).getValues();
  let headerRow = -1;

  for (let r = 0; r < range.length; r++) {
    const row = range[r].map(v => String(v || "").trim().toLowerCase());
    if (header.every(h => row.includes(h.toLowerCase()))) {
      headerRow = r + 1;
      break;
    }
  }

  // If not found, force recreate header at row 1
  if (headerRow === -1) {
    sh.clear();
    sh.getRange(1,1,1,header.length).setValues([header]);
    headerRow = 1;
  }

  // Append data under last row
  const insertRow = sh.getLastRow() + 1;

  sh.getRange(insertRow, 1, 1, header.length).setValues([[
    new Date(),
    p.ID,
    p.SCORE,
    p["FALSE START"],
    p.REMARK,
    p.NAME1, p.NAME2, p.NAME3, p.NAME4,
    p.TEAM, p.STATE, p.HEAT, p.STATION, p.EVENT, p.DIVISION
  ]]);

  return { ok:true };
}
