/** ============================================================
 * GBRSA BACKEND 2025 — FINAL SINGLE-FILE VERSION
 * Supports:
 * ✔ SPEED scoring (append)
 * ✔ FREESTYLE scoring (4-judge MERGE into RESULT_F)
 * ✔ STATION LIST
 * ✔ PARTICIPANT LOOKUP
 * ✔ DYNAMIC HEADER MAPPING
 * ============================================================ **/

/* ------------------------------------------------------------
 * 1️⃣ CONFIG
 * ------------------------------------------------------------ */
function getConfig() {
  const SP = PropertiesService.getScriptProperties();
  return {
    SHEET_ID: SP.getProperty("SHEET_ID") || "YOUR_SHEET_ID",
    DATA_SHEET: SP.getProperty("DATA_SHEET_NAME") || "DATA",
    RESULT_SHEET_SPEED: SP.getProperty("RESULT_SHEET_NAME") || "RESULT",
    RESULT_SHEET_FREESTYLE: SP.getProperty("RESULT_F_SHEET_NAME") || "RESULT_F",
    TZ: "Asia/Kuala_Lumpur"
  };
}

/* ------------------------------------------------------------
 * 2️⃣ UTILITIES
 * ------------------------------------------------------------ */
function json(o) {
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

function normalize(s) {
  return String(s || "").trim();
}

function safe(v) {
  return v == null ? "" : v;
}

function lowerHeaders(row) {
  return row.map(v => String(v || "").toLowerCase().trim());
}

function toDate(val, tz) {
  if (val instanceof Date) return val;
  try {
    const d = new Date(
      Utilities.formatDate(new Date(val), tz, "yyyy-MM-dd'T'HH:mm:ss")
    );
    return isNaN(d) ? null : d;
  } catch (e) {
    return null;
  }
}

/** Dynamic write-to-row helper */
function writeRowByHeader(sh, data) {
  const header = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const hmap = {};

  header.forEach((h, i) => {
    const key = String(h || "").trim().toLowerCase();
    if (key) hmap[key] = i + 1;
  });

  const row = new Array(header.length).fill("");
  for (const key in data) {
    const col = hmap[key.toLowerCase()];
    if (col) row[col - 1] = data[key];
  }

  sh.appendRow(row);
}

/* ------------------------------------------------------------
 * 3️⃣ ROUTER
 * ------------------------------------------------------------ */
function doGet(e) {
  const cmd = (e.parameter.cmd || "").toLowerCase();

  switch (cmd) {
    case "participant":
      return getParticipant(e);

    case "stationlist":
      return getStationList(e);

    case "ping":
      return json({ ok: true, ts: Date.now() });

    default:
      return json({ ok: true, msg: "GBRSA backend online" });
  }
}

function doPost(e) {
  try {
    let p = {};

    if (e.postData?.contents) {
      try {
        p = JSON.parse(e.postData.contents);
      } catch {
        p = e.parameter;
      }
    } else {
      p = e.parameter;
    }

    const form = (p._form || "").toLowerCase();

    if (form === "freestyle") return json(writeFreestyle(p));
    return json(writeSpeed(p));

  } catch (err) {
    return json({ ok: false, error: String(err) });
  }
}

/* ------------------------------------------------------------
 * 4️⃣ PARTICIPANT LOOKUP
 * ------------------------------------------------------------ */
function getParticipant(e) {
  const { SHEET_ID, DATA_SHEET } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const vals = sh.getRange(1, 1, sh.getLastRow(), 20).getValues();
  const header = vals[0];
  const map = buildHeaderMap(header);

  const id = normalize(e.parameter.entryId);

  for (let r = 1; r < vals.length; r++) {
    if (normalize(vals[r][map.id]) === id) {
      const row = vals[r];

      return json({
        ok: true,
        participant: {
          ID: id,
          NAME1: row[map.name1],
          NAME2: row[map.name2],
          NAME3: row[map.name3],
          NAME4: row[map.name4],
          TEAM: row[map.team],
          STATE: row[map.state],
          HEAT: row[map.heat],
          STATION: row[map.station],
          EVENT: row[map.event],
          DIVISION: row[map.division]
        }
      });
    }
  }

  return json({ ok: false, error: "ID not found" });
}

function buildHeaderMap(header) {
  const H = lowerHeaders(header);
  const find = names => H.findIndex(h => names.includes(h));

  return {
    id: find(["id"]),
    name1: find(["name1"]),
    name2: find(["name2"]),
    name3: find(["name3"]),
    name4: find(["name4"]),
    team: find(["team"]),
    state: find(["state"]),
    heat: find(["heat"]),
    station: find(["station"]),
    event: find(["event"]),
    division: find(["division"])
  };
}

/* ------------------------------------------------------------
 * 5️⃣ SUPER FAST STATION LIST (0.2–0.4 sec)
 * ------------------------------------------------------------ */
function getStationList(e) {
  const { SHEET_ID, DATA_SHEET } = getConfig();

  const station = (e.parameter.station || "").trim();

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const last = sh.getLastRow();
  if (last < 2) return json({ ok: true, station, entries: [] });

  // Read ONLY the first 15 columns (MUCH FASTER than reading 20)
  const values = sh.getRange(1, 1, last, 15).getValues();
  const header = lowerHeaders(values[0]);

  // Build map once
  const map = {};
  header.forEach((h, i) => map[h] = i);

  const entries = [];

  for (let r = 1; r < last; r++) {
    const row = values[r];

    // Quick station match
    if (String(row[map["station"]] || "").trim() !== station) continue;

    const id = String(row[map["id"]] || "").trim();
    if (!id) continue;

    // Fast displayName (no filter/join)
    let displayName = "";
    const n1 = row[map["name1"]] || "";
    const n2 = row[map["name2"]] || "";
    const n3 = row[map["name3"]] || "";
    const n4 = row[map["name4"]] || "";

    if (n1) displayName += n1 + " ";
    if (n2) displayName += n2 + " ";
    if (n3) displayName += n3 + " ";
    if (n4) displayName += n4;

    entries.push({
      entryId: id,
      NAME1: n1,
      NAME2: n2,
      NAME3: n3,
      NAME4: n4,
      team: row[map["team"]] || "",
      state: row[map["state"]] || "",
      heat: row[map["heat"]] || "",
      station: station,
      event: row[map["event"]] || "",
      division: row[map["division"]] || "",
      displayName: displayName.trim(),
      status: "pending"
    });
  }

  return json({ ok: true, station, entries });
}

/* ------------------------------------------------------------
 * 6️⃣ SPEED WRITER (append only)
 * ------------------------------------------------------------ */
function writeSpeed(p) {
  const { SHEET_ID, RESULT_SHEET_SPEED } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(RESULT_SHEET_SPEED);

  if (!sh) throw new Error("RESULT sheet missing!");

  const data = {
    TIMESTAMP: new Date(),
    ID: p.ID,
    SCORE: p.SCORE,
    "FALSE START": p["FALSE START"],
    REMARK: p.REMARK,
    NAME1: p.NAME1,
    NAME2: p.NAME2,
    NAME3: p.NAME3,
    NAME4: p.NAME4,
    TEAM: p.TEAM,
    STATE: p.STATE,
    HEAT: p.HEAT,
    STATION: p.STATION,
    EVENT: p.EVENT,
    DIVISION: p.DIVISION
  };

  writeRowByHeader(sh, data);
  return { ok: true };
}

/* ------------------------------------------------------------
 * 7️⃣ FREESTYLE 4-JUDGE MERGE WRITER
 * ------------------------------------------------------------ */
function writeFreestyle(p) {
  const { SHEET_ID, RESULT_SHEET_FREESTYLE } = getConfig();

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(RESULT_SHEET_FREESTYLE);

  if (!sh) throw new Error("RESULT_F sheet not found");

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();

  const header = sh.getRange(1, 1, 1, lastCol).getValues()[0];
  const hmap = {};
  header.forEach((h, i) => (hmap[String(h).trim().toLowerCase()] = i + 1));

  const ID = String(p.ID).trim();
  let targetRow = -1;

  // Locate existing row
  for (let r = 2; r <= lastRow; r++) {
    const rid = String(sh.getRange(r, hmap["id"]).getValue()).trim();
    if (rid === ID) {
      targetRow = r;
      break;
    }
  }

  // If no row → create one
  if (targetRow === -1) {
    targetRow = lastRow + 1;
    sh.getRange(targetRow, 1, 1, lastCol).setValues([new Array(lastCol).fill("")]);
  }

  // MERGE updates
  const updates = {};

  if (p.DIFF !== undefined && p.DIFF !== "") updates["diff"] = p.DIFF;
  if (p.MISSES !== undefined && p.MISSES !== "") updates["misses"] = p.MISSES;
  if (p.BREAKS !== undefined && p.BREAKS !== "") updates["breaks"] = p.BREAKS;
  if (p.MissRE !== undefined && p.MissRE !== "") updates["missre"] = p.MissRE;
  if (p.PRESENTATION !== undefined && p.PRESENTATION !== "")
    updates["presentation"] = p.PRESENTATION;

  // Identity fields
  Object.assign(updates, {
    timestamp: new Date(),
    id: p.ID,
    name1: p.NAME1,
    team: p.TEAM,
    state: p.STATE,
    heat: p.HEAT,
    station: p.STATION,
    event: p.EVENT,
    division: p.DIVISION
  });

  // Apply merged updates
  for (const key in updates) {
    const col = hmap[key.toLowerCase()];
    if (col) {
      sh.getRange(targetRow, col).setValue(updates[key]);
    }
  }

  return { ok: true, row: targetRow };
}
