/** ============================================================
 * GBRSA BACKEND 2025 — FINAL SINGLE-FILE VERSION
 * Supports:
 * ✔ SPEED scoring (append)
 * ✔ FREESTYLE scoring (4-judge MERGE into RESULT_F)
 * ✔ STATION LIST
 * ✔ PARTICIPANT LOOKUP
 * ✔ DYNAMIC HEADER MAPPING
 * ============================================================ **/

/* ------------------------------------------------------------
 * 1️⃣ CONFIG
 * ------------------------------------------------------------ */
function getConfig() {
  const SP = PropertiesService.getScriptProperties();
  return {
    SHEET_ID: SP.getProperty("SHEET_ID") || "YOUR_SHEET_ID",
    DATA_SHEET: SP.getProperty("DATA_SHEET_NAME") || "DATA",
    RESULT_SHEET_SPEED: SP.getProperty("RESULT_SHEET_NAME") || "RESULT",
    RESULT_SHEET_FREESTYLE: SP.getProperty("RESULT_F_SHEET_NAME") || "RESULT_F",
    TZ: "Asia/Kuala_Lumpur"
  };
}

/* ------------------------------------------------------------
 * 2️⃣ UTILITIES
 * ------------------------------------------------------------ */
function json(o) {
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

function normalize(s) {
  return String(s || "").trim();
}

function safe(v) {
  return v == null ? "" : v;
}

function lowerHeaders(row) {
  return row.map(v => String(v || "").toLowerCase().trim());
}

function toDate(val, tz) {
  if (val instanceof Date) return val;
  try {
    const d = new Date(
      Utilities.formatDate(new Date(val), tz, "yyyy-MM-dd'T'HH:mm:ss")
    );
    return isNaN(d) ? null : d;
  } catch (e) {
    return null;
  }
}

/** Dynamic write-to-row helper */
function writeRowByHeader(sh, data) {
  const header = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const hmap = {};

  header.forEach((h, i) => {
    const key = String(h || "").trim().toLowerCase();
    if (key) hmap[key] = i + 1;
  });

  const row = new Array(header.length).fill("");
  for (const key in data) {
    const col = hmap[key.toLowerCase()];
    if (col) row[col - 1] = data[key];
  }

  sh.appendRow(row);
}

/* ------------------------------------------------------------
 * 3️⃣ ROUTER
 * ------------------------------------------------------------ */
function doGet(e) {
  const cmd = (e.parameter.cmd || "").toLowerCase();

  switch (cmd) {
    case "participant":
      return getParticipant(e);

    case "stationlist":
      return getStationList(e);

    case "ping":
      return json({ ok: true, ts: Date.now() });

    default:
      return json({ ok: true, msg: "GBRSA backend online" });
  }
}

function doPost(e) {
  try {
    let p = {};

    if (e.postData?.contents) {
      try {
        p = JSON.parse(e.postData.contents);
      } catch {
        p = e.parameter;
      }
    } else {
      p = e.parameter;
    }

    const form = (p._form || "").toLowerCase();

    if (form === "freestyle") return json(writeFreestyle(p));
    return json(writeSpeed(p));

  } catch (err) {
    return json({ ok: false, error: String(err) });
  }
}

/* ------------------------------------------------------------
 * 4️⃣ PARTICIPANT LOOKUP
 * ------------------------------------------------------------ */
function getParticipant(e) {
  const { SHEET_ID, DATA_SHEET } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const vals = sh.getRange(1, 1, sh.getLastRow(), 20).getValues();
  const header = vals[0];
  const map = buildHeaderMap(header);

  const id = normalize(e.parameter.entryId);

  for (let r = 1; r < vals.length; r++) {
    if (normalize(vals[r][map.id]) === id) {
      const row = vals[r];

      return json({
        ok: true,
        participant: {
          ID: id,
          NAME1: row[map.name1],
          NAME2: row[map.name2],
          NAME3: row[map.name3],
          NAME4: row[map.name4],
          TEAM: row[map.team],
          STATE: row[map.state],
          HEAT: row[map.heat],
          STATION: row[map.station],
          EVENT: row[map.event],
          DIVISION: row[map.division]
        }
      });
    }
  }

  return json({ ok: false, error: "ID not found" });
}

function buildHeaderMap(header) {
  const H = lowerHeaders(header);
  const find = names => H.findIndex(h => names.includes(h));

  return {
    id: find(["id"]),
    name1: find(["name1"]),
    name2: find(["name2"]),
    name3: find(["name3"]),
    name4: find(["name4"]),
    team: find(["team"]),
    state: find(["state"]),
    heat: find(["heat"]),
    station: find(["station"]),
    event: find(["event"]),
    division: find(["division"])
  };
}

function getStationList(e) {
  const { SHEET_ID, DATA_SHEET, RESULT_SHEET_SPEED, TZ } = getConfig();
  const station = normalize(e.parameter.station);

  const ss = SpreadsheetApp.openById(SHEET_ID);

  // ===============================
  //  READ DATA SHEET
  // ===============================
  const dataSh = ss.getSheetByName(DATA_SHEET);
  const dVals = dataSh.getRange(1, 1, dataSh.getLastRow(), 20).getValues();
  const header = dVals[0];
  const map = buildHeaderMap(header);

  const entries = [];

  for (let r = 1; r < dVals.length; r++) {
    if (normalize(dVals[r][map.station]) !== station) continue;

    const id = normalize(dVals[r][map.id]);
    if (!id) continue;

    const row = dVals[r];

    entries.push({
      entryId: id,
      NAME1: safe(row[map.name1]),
      NAME2: safe(row[map.name2]),
      NAME3: safe(row[map.name3]),
      NAME4: safe(row[map.name4]),
      team: safe(row[map.team]),
      state: safe(row[map.state]),
      heat: safe(row[map.heat]),
      station: safe(row[map.station]),
      event: safe(row[map.event]),
      division: safe(row[map.division]),
      displayName: [row[map.name1], row[map.name2], row[map.name3], row[map.name4]].filter(Boolean).join(" "),
      status: "pending"
    });
  }

  // ===============================
  //  READ RESULT SHEET — SAME LOGIC AS OLD BACKEND
  // ===============================
  const resultSh = ss.getSheetByName(RESULT_SHEET_SPEED);
  const judgedToday = new Set();

  if (resultSh) {
    const rv = resultSh.getRange(1, 1, resultSh.getLastRow(), 20).getValues();
    const rh = lowerHeaders(rv[0]);

    const tsC = rh.indexOf("timestamp");   // IMPORTANT: FIXED INDEX
    const idC = rh.indexOf("id");
    const stC = rh.indexOf("station");

    if (tsC === -1 || idC === -1 || stC === -1) {
      // fallback to support older sheets
      return json({ ok: true, station, entries });
    }

    const now = new Date(); // Faster than toDate

    for (let r = 1; r < rv.length; r++) {
      const ts = rv[r][tsC];
      if (!(ts instanceof Date)) continue; // skip blank or invalid

      const sameDay =
        ts.getFullYear() === now.getFullYear() &&
        ts.getMonth() === now.getMonth() &&
        ts.getDate() === now.getDate();

      if (sameDay && normalize(rv[r][stC]) === station) {
        judgedToday.add(normalize(rv[r][idC]));
      }
    }
  }

  // APPLY DONE STATE
  entries.forEach(e => {
    if (judgedToday.has(e.entryId)) {
      e.status = "done";
    }
  });

  return json({ ok: true, station, entries });
}

/* ------------------------------------------------------------
 * 6️⃣ SPEED WRITER (append only)
 * ------------------------------------------------------------ */
function writeSpeed(p) {
  const { SHEET_ID, RESULT_SHEET_SPEED } = getConfig();
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(RESULT_SHEET_SPEED);

  if (!sh) throw new Error("RESULT sheet missing!");

  const data = {
    TIMESTAMP: new Date(),
    ID: p.ID,
    SCORE: p.SCORE,
    "FALSE START": p["FALSE START"],
    REMARK: p.REMARK,
    NAME1: p.NAME1,
    NAME2: p.NAME2,
    NAME3: p.NAME3,
    NAME4: p.NAME4,
    TEAM: p.TEAM,
    STATE: p.STATE,
    HEAT: p.HEAT,
    STATION: p.STATION,
    EVENT: p.EVENT,
    DIVISION: p.DIVISION
  };

  writeRowByHeader(sh, data);
  return { ok: true };
}

/* ------------------------------------------------------------
 * 7️⃣ FREESTYLE 4-JUDGE MERGE WRITER
 * ------------------------------------------------------------ */
function writeFreestyle(p) {
  const { SHEET_ID, RESULT_SHEET_FREESTYLE } = getConfig();

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sh = ss.getSheetByName(RESULT_SHEET_FREESTYLE);

  if (!sh) throw new Error("RESULT_F sheet not found");

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();

  const header = sh.getRange(1, 1, 1, lastCol).getValues()[0];
  const hmap = {};
  header.forEach((h, i) => (hmap[String(h).trim().toLowerCase()] = i + 1));

  const ID = String(p.ID).trim();
  let targetRow = -1;

  // Locate existing row
  for (let r = 2; r <= lastRow; r++) {
    const rid = String(sh.getRange(r, hmap["id"]).getValue()).trim();
    if (rid === ID) {
      targetRow = r;
      break;
    }
  }

  // If no row → create one
  if (targetRow === -1) {
    targetRow = lastRow + 1;
    sh.getRange(targetRow, 1, 1, lastCol).setValues([new Array(lastCol).fill("")]);
  }

  // MERGE updates
  const updates = {};

  if (p.DIFF !== undefined && p.DIFF !== "") updates["diff"] = p.DIFF;
  if (p.MISSES !== undefined && p.MISSES !== "") updates["misses"] = p.MISSES;
  if (p.BREAKS !== undefined && p.BREAKS !== "") updates["breaks"] = p.BREAKS;
  if (p.MissRE !== undefined && p.MissRE !== "") updates["missre"] = p.MissRE;
  if (p.PRESENTATION !== undefined && p.PRESENTATION !== "")
    updates["presentation"] = p.PRESENTATION;

  // Identity fields
  Object.assign(updates, {
    timestamp: new Date(),
    id: p.ID,
    name1: p.NAME1,
    team: p.TEAM,
    state: p.STATE,
    heat: p.HEAT,
    station: p.STATION,
    event: p.EVENT,
    division: p.DIVISION
  });

  // Apply merged updates
  for (const key in updates) {
    const col = hmap[key.toLowerCase()];
    if (col) {
      sh.getRange(targetRow, col).setValue(updates[key]);
    }
  }

  return { ok: true, row: targetRow };
}
